import{arrow as e,computePosition as t}from"@floating-ui/dom";export{autoPlacement,autoUpdate,computePosition,detectOverflow,flip,getOverflowAncestors,hide,inline,limitShift,offset,platform,shift,size}from"@floating-ui/dom";import*as r from"react";import{useLayoutEffect as n,useEffect as o}from"react";import*as i from"react-dom";const u=t=>({name:"arrow",options:t,fn(r){const{element:n,padding:o}="function"==typeof t?t(r):t;return n&&(i=n,{}.hasOwnProperty.call(i,"current"))?null!=n.current?e({element:n.current,padding:o}).fn(r):{}:n?e({element:n,padding:o}).fn(r):{};var i}});var f="undefined"!=typeof document?n:o;function s(e,t){if(e===t)return!0;if(typeof e!=typeof t)return!1;if("function"==typeof e&&e.toString()===t.toString())return!0;let r,n,o;if(e&&t&&"object"==typeof e){if(Array.isArray(e)){if(r=e.length,r!=t.length)return!1;for(n=r;0!=n--;)if(!s(e[n],t[n]))return!1;return!0}if(o=Object.keys(e),r=o.length,r!==Object.keys(t).length)return!1;for(n=r;0!=n--;)if(!{}.hasOwnProperty.call(t,o[n]))return!1;for(n=r;0!=n--;){const r=o[n];if(("_owner"!==r||!e.$$typeof)&&!s(e[r],t[r]))return!1}return!0}return e!=e&&t!=t}function a(e){if("undefined"==typeof window)return 1;return(e.ownerDocument.defaultView||window).devicePixelRatio||1}function c(e,t){const r=a(e);return Math.round(t*r)/r}function l(e){const t=r.useRef(e);return f((()=>{t.current=e})),t}function m(e){void 0===e&&(e={});const{placement:n="bottom",strategy:o="absolute",middleware:u=[],platform:m,elements:{reference:p,floating:d}={},transform:g=!0,whileElementsMounted:y,open:w}=e,[h,P]=r.useState({x:0,y:0,strategy:o,placement:n,middlewareData:{},isPositioned:!1}),[S,b]=r.useState(u);s(S,u)||b(u);const[x,M]=r.useState(null),[R,k]=r.useState(null),v=r.useCallback((e=>{e!=A.current&&(A.current=e,M(e))}),[M]),O=r.useCallback((e=>{e!==D.current&&(D.current=e,k(e))}),[k]),C=p||x,j=d||R,A=r.useRef(null),D=r.useRef(null),$=r.useRef(h),q=l(y),z=l(m),E=r.useCallback((()=>{if(!A.current||!D.current)return;const e={placement:n,strategy:o,middleware:S};z.current&&(e.platform=z.current);const r={...t(A.current,D.current,e),isPositioned:!0};F.current&&!s($.current,r)&&($.current=r,queueMicrotask((()=>{i.flushSync((()=>{P(r)}))})))}),[S,n,o,z]);f((()=>{!1===w&&$.current.isPositioned&&($.current.isPositioned=!1,P((e=>({...e,isPositioned:!1}))))}),[w]);const F=r.useRef(!1);f((()=>(F.current=!0,()=>{F.current=!1})),[]),f((()=>{if(C&&(A.current=C),j&&(D.current=j),C&&j){if(q.current)return q.current(C,j,E);E()}}),[C,j,E,q]);const U=r.useMemo((()=>({reference:A,floating:D,setReference:v,setFloating:O})),[v,O]),V=r.useMemo((()=>({reference:C,floating:j})),[C,j]),_=r.useMemo((()=>{const e={position:o,left:0,top:0};if(!V.floating)return e;const t=c(V.floating,h.x),r=c(V.floating,h.y);return g?{...e,transform:"translate("+t+"px, "+r+"px)",...a(V.floating)>=1.5&&{willChange:"transform"}}:{position:o,left:t,top:r}}),[o,g,V.floating,h.x,h.y]);return r.useMemo((()=>({...h,update:E,refs:U,elements:V,floatingStyles:_})),[h,E,U,V,_])}export{u as arrow,m as useFloating};
